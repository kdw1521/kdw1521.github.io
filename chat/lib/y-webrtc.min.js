/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /npm/y-webrtc@10.3.0/src/y-webrtc.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import*as ws from"lib0/websocket";import*as map from"lib0/map";import*as error from"lib0/error";import*as random from"lib0/random";import*as encoding from"lib0/encoding";import*as decoding from"lib0/decoding";import{ObservableV2}from"lib0/observable";import*as logging from"lib0/logging";import*as promise from"lib0/promise";import*as bc from"lib0/broadcastchannel";import*as buffer from"lib0/buffer";import*as math from"lib0/math";import{createMutex}from"lib0/mutex";import*as Y from"yjs";import Peer from"simple-peer/simplepeer.min.js";import*as syncProtocol from"y-protocols/sync";import*as awarenessProtocol from"y-protocols/awareness";import*as cryptoutils from"./crypto.js";const log=logging.createModuleLogger("y-webrtc"),messageSync=0,messageQueryAwareness=3,messageAwareness=1,messageBcPeerId=4,signalingConns=new Map,rooms=new Map,checkIsSynced=e=>{let n=!0;e.webrtcConns.forEach((e=>{e.synced||(n=!1)})),(!n&&e.synced||n&&!e.synced)&&(e.synced=n,e.provider.emit("synced",[{synced:n}]),log("synced ",logging.BOLD,e.name,logging.UNBOLD," with all peers"))},readMessage=(e,n,o)=>{const s=decoding.createDecoder(n),t=encoding.createEncoder(),r=decoding.readVarUint(s);if(void 0===e)return null;const i=e.awareness,c=e.doc;let a=!1;switch(r){case 0:{encoding.writeVarUint(t,0);const n=syncProtocol.readSyncMessage(s,t,c,e);n!==syncProtocol.messageYjsSyncStep2||e.synced||o(),n===syncProtocol.messageYjsSyncStep1&&(a=!0);break}case 3:encoding.writeVarUint(t,1),encoding.writeVarUint8Array(t,awarenessProtocol.encodeAwarenessUpdate(i,Array.from(i.getStates().keys()))),a=!0;break;case 1:awarenessProtocol.applyAwarenessUpdate(i,decoding.readVarUint8Array(s),e);break;case 4:{const n=1===decoding.readUint8(s),o=decoding.readVarString(s);if(o!==e.peerId&&(e.bcConns.has(o)&&!n||!e.bcConns.has(o)&&n)){const s=[],t=[];n?(e.bcConns.add(o),t.push(o)):(e.bcConns.delete(o),s.push(o)),e.provider.emit("peers",[{added:t,removed:s,webrtcPeers:Array.from(e.webrtcConns.keys()),bcPeers:Array.from(e.bcConns)}]),broadcastBcPeerId(e)}break}default:return console.error("Unable to compute message"),t}return a?t:null},readPeerMessage=(e,n)=>{const o=e.room;return log("received message from ",logging.BOLD,e.remotePeerId,logging.GREY," (",o.name,")",logging.UNBOLD,logging.UNCOLOR),readMessage(o,n,(()=>{e.synced=!0,log("synced ",logging.BOLD,o.name,logging.UNBOLD," with ",logging.BOLD,e.remotePeerId),checkIsSynced(o)}))},sendWebrtcConn=(e,n)=>{log("send message to ",logging.BOLD,e.remotePeerId,logging.UNBOLD,logging.GREY," (",e.room.name,")",logging.UNCOLOR);try{e.peer.send(encoding.toUint8Array(n))}catch(e){}},broadcastWebrtcConn=(e,n)=>{log("broadcast message in ",logging.BOLD,e.name,logging.UNBOLD),e.webrtcConns.forEach((e=>{try{e.peer.send(n)}catch(e){}}))};export class WebrtcConn{constructor(e,n,o,s){log("establishing connection to ",logging.BOLD,o),this.room=s,this.remotePeerId=o,this.glareToken=void 0,this.closed=!1,this.connected=!1,this.synced=!1,this.peer=new Peer({initiator:n,...s.provider.peerOpts}),this.peer.on("signal",(n=>{void 0===this.glareToken&&(this.glareToken=Date.now()+Math.random()),publishSignalingMessage(e,s,{to:o,from:s.peerId,type:"signal",token:this.glareToken,signal:n})})),this.peer.on("connect",(()=>{log("connected to ",logging.BOLD,o),this.connected=!0;const e=s.provider.doc,n=s.awareness,t=encoding.createEncoder();encoding.writeVarUint(t,0),syncProtocol.writeSyncStep1(t,e),sendWebrtcConn(this,t);const r=n.getStates();if(r.size>0){const e=encoding.createEncoder();encoding.writeVarUint(e,1),encoding.writeVarUint8Array(e,awarenessProtocol.encodeAwarenessUpdate(n,Array.from(r.keys()))),sendWebrtcConn(this,e)}})),this.peer.on("close",(()=>{this.connected=!1,this.closed=!0,s.webrtcConns.has(this.remotePeerId)&&(s.webrtcConns.delete(this.remotePeerId),s.provider.emit("peers",[{removed:[this.remotePeerId],added:[],webrtcPeers:Array.from(s.webrtcConns.keys()),bcPeers:Array.from(s.bcConns)}])),checkIsSynced(s),this.peer.destroy(),log("closed connection to ",logging.BOLD,o),announceSignalingInfo(s)})),this.peer.on("error",(e=>{log("Error in connection to ",logging.BOLD,o,": ",e),announceSignalingInfo(s)})),this.peer.on("data",(e=>{const n=readPeerMessage(this,e);null!==n&&sendWebrtcConn(this,n)}))}destroy(){this.peer.destroy()}}const broadcastBcMessage=(e,n)=>cryptoutils.encrypt(n,e.key).then((n=>e.mux((()=>bc.publish(e.name,n))))),broadcastRoomMessage=(e,n)=>{e.bcconnected&&broadcastBcMessage(e,n),broadcastWebrtcConn(e,n)},announceSignalingInfo=e=>{signalingConns.forEach((n=>{n.connected&&(n.send({type:"subscribe",topics:[e.name]}),e.webrtcConns.size<e.provider.maxConns&&publishSignalingMessage(n,e,{type:"announce",from:e.peerId}))}))},broadcastBcPeerId=e=>{if(e.provider.filterBcConns){const n=encoding.createEncoder();encoding.writeVarUint(n,4),encoding.writeUint8(n,1),encoding.writeVarString(n,e.peerId),broadcastBcMessage(e,encoding.toUint8Array(n))}};export class Room{constructor(e,n,o,s){this.peerId=random.uuidv4(),this.doc=e,this.awareness=n.awareness,this.provider=n,this.synced=!1,this.name=o,this.key=s,this.webrtcConns=new Map,this.bcConns=new Set,this.mux=createMutex(),this.bcconnected=!1,this._bcSubscriber=e=>cryptoutils.decrypt(new Uint8Array(e),s).then((e=>this.mux((()=>{const n=readMessage(this,e,(()=>{}));n&&broadcastBcMessage(this,encoding.toUint8Array(n))})))),this._docUpdateHandler=(e,n)=>{const o=encoding.createEncoder();encoding.writeVarUint(o,0),syncProtocol.writeUpdate(o,e),broadcastRoomMessage(this,encoding.toUint8Array(o))},this._awarenessUpdateHandler=({added:e,updated:n,removed:o},s)=>{const t=e.concat(n).concat(o),r=encoding.createEncoder();encoding.writeVarUint(r,1),encoding.writeVarUint8Array(r,awarenessProtocol.encodeAwarenessUpdate(this.awareness,t)),broadcastRoomMessage(this,encoding.toUint8Array(r))},this._beforeUnloadHandler=()=>{awarenessProtocol.removeAwarenessStates(this.awareness,[e.clientID],"window unload"),rooms.forEach((e=>{e.disconnect()}))},"undefined"!=typeof window?window.addEventListener("beforeunload",this._beforeUnloadHandler):"undefined"!=typeof process&&process.on("exit",this._beforeUnloadHandler)}connect(){this.doc.on("update",this._docUpdateHandler),this.awareness.on("update",this._awarenessUpdateHandler),announceSignalingInfo(this);const e=this.name;bc.subscribe(e,this._bcSubscriber),this.bcconnected=!0,broadcastBcPeerId(this);const n=encoding.createEncoder();encoding.writeVarUint(n,0),syncProtocol.writeSyncStep1(n,this.doc),broadcastBcMessage(this,encoding.toUint8Array(n));const o=encoding.createEncoder();encoding.writeVarUint(o,0),syncProtocol.writeSyncStep2(o,this.doc),broadcastBcMessage(this,encoding.toUint8Array(o));const s=encoding.createEncoder();encoding.writeVarUint(s,3),broadcastBcMessage(this,encoding.toUint8Array(s));const t=encoding.createEncoder();encoding.writeVarUint(t,1),encoding.writeVarUint8Array(t,awarenessProtocol.encodeAwarenessUpdate(this.awareness,[this.doc.clientID])),broadcastBcMessage(this,encoding.toUint8Array(t))}disconnect(){signalingConns.forEach((e=>{e.connected&&e.send({type:"unsubscribe",topics:[this.name]})})),awarenessProtocol.removeAwarenessStates(this.awareness,[this.doc.clientID],"disconnect");const e=encoding.createEncoder();encoding.writeVarUint(e,4),encoding.writeUint8(e,0),encoding.writeVarString(e,this.peerId),broadcastBcMessage(this,encoding.toUint8Array(e)),bc.unsubscribe(this.name,this._bcSubscriber),this.bcconnected=!1,this.doc.off("update",this._docUpdateHandler),this.awareness.off("update",this._awarenessUpdateHandler),this.webrtcConns.forEach((e=>e.destroy()))}destroy(){this.disconnect(),"undefined"!=typeof window?window.removeEventListener("beforeunload",this._beforeUnloadHandler):"undefined"!=typeof process&&process.off("exit",this._beforeUnloadHandler)}}const openRoom=(e,n,o,s)=>{if(rooms.has(o))throw error.create(`A Yjs Doc connected to room "${o}" already exists!`);const t=new Room(e,n,o,s);return rooms.set(o,t),t},publishSignalingMessage=(e,n,o)=>{n.key?cryptoutils.encryptJson(o,n.key).then((o=>{e.send({type:"publish",topic:n.name,data:buffer.toBase64(o)})})):e.send({type:"publish",topic:n.name,data:o})};export class SignalingConn extends ws.WebsocketClient{constructor(e){super(e),this.providers=new Set,this.on("connect",(()=>{log(`connected (${e})`);const n=Array.from(rooms.keys());this.send({type:"subscribe",topics:n}),rooms.forEach((e=>publishSignalingMessage(this,e,{type:"announce",from:e.peerId})))})),this.on("message",(e=>{if("publish"===e.type){const n=e.topic,o=rooms.get(n);if(null==o||"string"!=typeof n)return;const s=e=>{const n=o.webrtcConns,s=o.peerId;if(null==e||e.from===s||void 0!==e.to&&e.to!==s||o.bcConns.has(e.from))return;const t=n.has(e.from)?()=>{}:()=>o.provider.emit("peers",[{removed:[],added:[e.from],webrtcPeers:Array.from(o.webrtcConns.keys()),bcPeers:Array.from(o.bcConns)}]);switch(e.type){case"announce":n.size<o.provider.maxConns&&(map.setIfUndefined(n,e.from,(()=>new WebrtcConn(this,!0,e.from,o))),t());break;case"signal":if("offer"===e.signal.type){const o=n.get(e.from);if(o){const n=e.token,s=o.glareToken;if(s&&s>n)return void log("offer rejected: ",e.from);o.glareToken=void 0}}if("answer"===e.signal.type){log("offer answered by: ",e.from);n.get(e.from).glareToken=void 0}e.to===s&&(map.setIfUndefined(n,e.from,(()=>new WebrtcConn(this,!1,e.from,o))).peer.signal(e.signal),t())}};o.key?"string"==typeof e.data&&cryptoutils.decryptJson(buffer.fromBase64(e.data),o.key).then(s):s(e.data)}})),this.on("disconnect",(()=>log(`disconnect (${e})`)))}}const emitStatus=e=>{e.emit("status",[{connected:e.connected}])};export class WebrtcProvider extends ObservableV2{constructor(e,n,{signaling:o=["wss://y-webrtc-eu.fly.dev"],password:s=null,awareness:t=new awarenessProtocol.Awareness(n),maxConns:r=20+math.floor(15*random.rand()),filterBcConns:i=!0,peerOpts:c={}}={}){super(),this.roomName=e,this.doc=n,this.filterBcConns=i,this.awareness=t,this.shouldConnect=!1,this.signalingUrls=o,this.signalingConns=[],this.maxConns=r,this.peerOpts=c,this.key=s?cryptoutils.deriveKey(s,e):promise.resolve(null),this.room=null,this.key.then((o=>{this.room=openRoom(n,this,e,o),this.shouldConnect?this.room.connect():this.room.disconnect(),emitStatus(this)})),this.connect(),this.destroy=this.destroy.bind(this),n.on("destroy",this.destroy)}get connected(){return null!==this.room&&this.shouldConnect}connect(){this.shouldConnect=!0,this.signalingUrls.forEach((e=>{const n=map.setIfUndefined(signalingConns,e,(()=>new SignalingConn(e)));this.signalingConns.push(n),n.providers.add(this)})),this.room&&(this.room.connect(),emitStatus(this))}disconnect(){this.shouldConnect=!1,this.signalingConns.forEach((e=>{e.providers.delete(this),0===e.providers.size&&(e.destroy(),signalingConns.delete(e.url))})),this.room&&(this.room.disconnect(),emitStatus(this))}destroy(){this.doc.off("destroy",this.destroy),this.key.then((()=>{this.room.destroy(),rooms.delete(this.roomName)})),super.destroy()}}
//# sourceMappingURL=/sm/11c5d818959d7b8fa3fc2c78fb849e68adbe00f486979ca0783dce42399bf2e0.map